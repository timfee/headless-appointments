{"version":3,"sources":["../../src/server/index.ts","../../src/server/availability.ts","../../src/server/busy.ts","../../src/server/offers.ts"],"sourcesContent":["import \"server-only\"\n\nimport { createAvailability, CreateAvailabilityProps } from \"./availability\"\nimport { getFreeBusyData, GetFreeBusyProps } from \"./busy\"\nimport { returnAvailableSlots } from \"./offers\"\nimport { DeepMergeTwoTypes } from \"./utils\"\n\ntype AppointParams = GetFreeBusyProps &\n  DeepMergeTwoTypes<\n    CreateAvailabilityProps,\n    {\n      bookingCriteria: {\n        padding: number\n      }\n    }\n  >\n\nexport default async function getAvailability(params?: AppointParams) {\n  if (!params?.start) throw new Error(\"No `start` date passed\")\n  if (!params?.end) throw new Error(\"No `end` date passed\")\n  if (!params.bookingCriteria.duration) throw new Error(\"No `duration` passed\")\n\n  let padding = params?.bookingCriteria.padding ?? 0\n\n  if (!params?.provider) throw new Error(\"No `provider` object passed\")\n  if (!params?.provider.OAuthClient)\n    throw new Error(\"`provider` doesn't contain OAuthClient\")\n  if (!params?.provider.OAuthCredentials)\n    throw new Error(\"`provider` doesn't include AuthCredentials\")\n\n  const { busySlots, timeZone } = await getFreeBusyData({\n    start: params.start,\n    end: params.end,\n    provider: {\n      name: \"google\",\n      OAuthClient: params.provider.OAuthClient,\n      OAuthCredentials: params.provider.OAuthCredentials,\n    },\n  })\n\n  const timeZoneOfStartAndEndTimes =\n    params?.timeZoneOfStartAndEndTimes ?? timeZone\n\n  const allSlots = createAvailability({\n    start: params.start,\n    end: params.end,\n    timeZoneOfStartAndEndTimes,\n    bookingCriteria: {\n      duration: params.bookingCriteria.duration,\n    },\n  })\n\n  const openSlots = returnAvailableSlots({\n    allSlots,\n    busySlots,\n    padding,\n  })\n\n  return openSlots\n}\n","import \"server-only\"\n\nimport { add, eachMinuteOfInterval, endOfHour, startOfHour } from \"date-fns\"\nimport { isFuture } from \"date-fns\"\nimport { utcToZonedTime } from \"date-fns-tz\"\n\nimport { DateInterval } from \"../shared\"\n\nexport type AvailabilitySlot = {\n  start: { hour: number; minute: number }\n  end: { hour: number; minute: number }\n}\n\nexport type AvailabilityType = {\n  [key: number]: AvailabilitySlot[]\n}\n\n/** Options for {@link createAvailability} */\nexport type CreateAvailabilityProps = {\n  /**\n   * The start date to begin looking for availability.\n   *\n   * Dates in the past are automatically excluded.\n   */\n  start: Date\n  /**\n   * The end date to stop looking for availability.\n   */\n  end: Date\n\n  /**\n   * A {@link https://en.wikipedia.org/wiki/List_of_tz_database_time_zones tz database name}\n   * for the timezone of the start and end dates.\n   *\n   * @example \"America/Los_Angeles\"\n   */\n  timeZoneOfStartAndEndTimes: string\n  /**\n   * Boking criteria is relevant to computing availability.\n   * In this case, we're just looking at `duration`.\n   */\n  bookingCriteria: {\n    duration: number\n  }\n  /**\n   * Options that determine what availability we offer\n   */\n  availability?: {\n    /**\n     * A map of days of the week to availability slots.\n     * The keys are numbers from 0-6, where 0 is Sunday and 6 is Saturday.\n     *\n     * The values are arrays of {@link AvailabilitySlot}\n     *\n     * If there's no availability provided for a given\n     * day of the week, {@link fallback} will be used.\n     *\n     * @example { 1: [ { start: { hour: 9, minute: 0 },\n     *    end: { hour: 12, minute: 0 },\n     *  }, { start: { hour: 14, minute: 30 },\n     *    end: { hour: 17, minute: 0 } }\n     * ]\n     */\n    dailySlots: AvailabilityType\n    /**\n     * A list of availability slots to use for any day of the week\n     * that doesn't have a value in {@link dailySlots}.\n     *\n     * @defaultValue 09:00 - 17:00 (5 PM)\n     */\n    fallback?: AvailabilitySlot[]\n    /**\n     * If true, availability will not be offered on weekends,\n     * even if {@link dailySlots} or {@link fallback} are provided.\n     */\n    forceExcludeWeekends?: boolean\n  }\n}\n\nexport function createAvailability({\n  start,\n  end,\n  timeZoneOfStartAndEndTimes,\n  bookingCriteria = {\n    duration: 30,\n  },\n  availability = {\n    dailySlots: {},\n    fallback: [\n      {\n        start: { hour: 9, minute: 0 },\n        end: { hour: 17, minute: 0 },\n      },\n    ],\n    forceExcludeWeekends: false,\n  },\n}: CreateAvailabilityProps): DateInterval[] {\n  // Required fields\n  if (!start) throw new Error(\"Missing start date\")\n  if (!end) throw new Error(\"Missing end date\")\n  if (!bookingCriteria.duration) throw new Error(\"Missing duration\")\n  if (!timeZoneOfStartAndEndTimes) throw new Error(\"Missing timeZone\")\n\n  // Use to keep track of all potential availability slots\n  const dailyAvailability: AvailabilityType = {}\n\n  // Use the fallback for any missing key, excluding weekends if desired\n  for (\n    let day = availability.forceExcludeWeekends\n      ? 1 /* Monday */\n      : 0 /* Sunday */;\n    day <\n    (availability.forceExcludeWeekends ? 5 /* Friday */ : 6) /* Saturday */;\n    day++\n  ) {\n    dailyAvailability[day] =\n      dailyAvailability[day] ?? availability.fallback ?? []\n  }\n\n  const intervals: DateInterval[] = eachMinuteOfInterval(\n    { start: startOfHour(start), end: endOfHour(end) },\n    {\n      step: bookingCriteria.duration,\n    }\n  )\n    // Filter out any slots that are in the past\n    .filter((date) => isFuture(date))\n    // Filter out any slots that are not in our availability\n    .filter((utcDate) => {\n      // Look at the day through the lens of the calendar owner's timezone.\n      const date = utcToZonedTime(utcDate, timeZoneOfStartAndEndTimes),\n        day = date.getDay(),\n        hour = date.getHours(),\n        minute = date.getMinutes(),\n        slots = dailyAvailability[day]\n\n      // Bail if there's no availability for this day.\n      if (!slots) return false\n\n      for (const slot of slots) {\n        // Bail if the hour starts before the slot's hour does.\n        if (hour < slot.start.hour) continue\n\n        // Bail if the hour ends after the slot's end does.\n        if (hour > slot.end.hour) continue\n\n        // Apply the same before and after logic for minutes\n        // when the hour is the same.\n        if (hour === slot.start.hour && minute < slot.start.minute) continue\n        if (hour === slot.end.hour && minute > slot.end.minute) continue\n\n        return true\n      }\n      return false\n    })\n    .map((date) => ({\n      start: date,\n      end: add(date, { minutes: bookingCriteria.duration }),\n    }))\n\n  return intervals\n}\n","import { type Auth, google } from \"googleapis\"\n\nimport { DateInterval } from \"../shared\"\n\nexport type GetFreeBusyProps = {\n  start: Date\n  end: Date\n} & FreeBusyProviders\n\ntype FreeBusyProviders = {\n  provider: {\n    name: \"google\"\n    OAuthClient: Auth.OAuth2ClientOptions\n    OAuthCredentials: Auth.Credentials\n  }\n}\n\nexport async function getFreeBusyData(params: GetFreeBusyProps) {\n  if (!params.start) throw new Error(\"getFreeBusyData: No start date provided\")\n  if (!params.end) throw new Error(\"getFreeBusyData: No end date provided\")\n\n  if (!params?.provider)\n    throw new Error(\"getFreeBusyData: No `provider` object passed\")\n  if (!params?.provider.OAuthClient)\n    throw new Error(\"getFreeBusyData: `provider` doesn't contain OAuthClient\")\n  if (!params?.provider.OAuthCredentials)\n    throw new Error(\n      \"getFreeBusyData: `provider` doesn't include AuthCredentials\"\n    )\n\n  const start = params?.start\n  const end = params?.end\n\n  let auth: Auth.OAuth2Client = new google.auth.OAuth2(\n    params.provider.OAuthClient\n  )\n  auth.setCredentials(params.provider.OAuthCredentials)\n\n  let calendar = google.calendar({ version: \"v3\", auth: auth })\n\n  // get the configured timezone, so we can use it as a default\n  // value in the main function, if we need to.\n  let timeZone =\n    (\n      await calendar.settings.get({\n        setting: \"timezone\",\n      })\n    ).data.value ?? \"UTC\"\n\n  // get busyData in UTC time,\n  // see https://developers.google.com/calendar/v3/reference/freebusy/query\n  const busyData = await calendar.freebusy.query({\n    requestBody: {\n      timeMin: start.toISOString(),\n      timeMax: end.toISOString(),\n      items: [{ id: \"primary\" }],\n    },\n  })\n\n  const busySlots: DateInterval[] = Object.values(\n    busyData.data?.calendars ?? {}\n  )\n    .flatMap((calendar) => calendar.busy!)\n    .sort((a, b) => {\n      const aStart = new Date(a.start ?? \"\")\n      const bStart = new Date(b.start ?? \"\")\n      const aEnd = new Date(a.end ?? \"\")\n      const bEnd = new Date(b.end ?? \"\")\n\n      if (aStart < bStart) return -1\n      if (aStart > bStart) return 1\n      if (aEnd < bEnd) return -1\n      if (aEnd > bEnd) return 1\n      return 0\n    })\n    .map((busy) => ({\n      start: new Date(busy.start ?? \"\"),\n      end: new Date(busy.end ?? \"\"),\n    }))\n\n  return { timeZone, busySlots }\n}\n","import { add, areIntervalsOverlapping, sub } from \"date-fns\"\n\nimport { DateInterval } from \"../shared\"\n\n/** Options for {@link returnAvailableSlots} */\nexport type ReturnAvailableSlotsProps = {\n  /**\n   * An array of intervalus we _could_ offer, provided\n   * there's no conflicting busy periods.\n   */\n  allSlots: DateInterval[]\n  /**\n   * An array of busy intervals to exclude from the\n   * final result.\n   */\n  busySlots: DateInterval[]\n  /**\n   * The number of minutes to \"pad\" each interval, e.g.\n   * start and end `padding` minutes earlier and later,\n   * respectively.\n   *\n   * Use 0 to disable padding.\n   */\n  padding: number\n}\n\nexport function returnAvailableSlots({\n  allSlots,\n  busySlots,\n  padding,\n}: ReturnAvailableSlotsProps) {\n  // Our final array of available slots\n  const openSlots: DateInterval[] = []\n\n  // Make a deep copy of the allSlots array\n  const remainingSlots = [...allSlots]\n\n  for (let i = 0; i < allSlots.length; i++) {\n    const freeSlot = allSlots[i]\n\n    // Check if the free slot overlaps with any busy slot\n    let isFree = true\n    for (let j = 0; j < busySlots.length; j++) {\n      const busySlot = busySlots[j]\n      const busyStart = sub(busySlot.start, { minutes: padding })\n      const busyEnd = add(busySlot.end, { minutes: padding })\n      if (\n        areIntervalsOverlapping(freeSlot, { start: busyStart, end: busyEnd })\n      ) {\n        isFree = false\n        break\n      }\n    }\n\n    // If the free slot is not booked, add it to the result\n    if (isFree) {\n      openSlots.push(freeSlot)\n    }\n\n    // Remove the free slot from the remainingSlots array\n    const index = remainingSlots.indexOf(freeSlot)\n    if (index !== -1) {\n      remainingSlots.splice(index, 1)\n    }\n  }\n\n  return openSlots\n}\n"],"mappings":"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","names":["import_server_only","import_date_fns","calendar","_a","_b","_c","import_date_fns"]}